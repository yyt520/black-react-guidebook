<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico" />
    <link rel="stylesheet" href="/black-react-guidebook/umi.b283d7b5.css" />
    <script>
      window.routerBase = "/black-react-guidebook/";
    </script>
    <script>
      //! umi version: 3.5.20
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>Fiber</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/infrastructure/new/fiber" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/react-guidebook-favicon.png&#x27;)" href="/black-react-guidebook//">React Guidebook</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span><a href="/black-react-guidebook//foundation">基础</a></span><span><a aria-current="page" class="active" href="/black-react-guidebook//infrastructure">架构</a></span><span><a href="/black-react-guidebook//ecosystem">生态</a></span><span><a href="/black-react-guidebook//api-reference">API</a></span><span><a href="/black-react-guidebook//extensions">扩展</a></span><span><a target="_blank" rel="noopener noreferrer" href="https://github.com/yyt520/black-react-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/react-guidebook-favicon.png&#x27;)" href="/black-react-guidebook//"></a><h1>React Guidebook</h1><p>React 完全知识体系</p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li><a href="/black-react-guidebook//foundation">基础</a></li><li><a aria-current="page" class="active" href="/black-react-guidebook//infrastructure">架构</a></li><li><a href="/black-react-guidebook//ecosystem">生态</a></li><li><a href="/black-react-guidebook//api-reference">API</a></li><li><a href="/black-react-guidebook//extensions">扩展</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/yyt520/black-react-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a target="_blank" rel="noopener noreferrer">新版架构</a><ul><li><a aria-current="page" class="active" href="/black-react-guidebook//infrastructure/new/fiber"><span>Fiber</span></a></li><li><a href="/black-react-guidebook//infrastructure/new/reconciliation"><span>Reconciliation</span></a></li><li><a href="/black-react-guidebook//infrastructure/new/concurrent"><span>Concurrent</span></a></li><li><a href="/black-react-guidebook//infrastructure/new/scheduler"><span>Scheduler</span></a></li></ul></li><li><a target="_blank" rel="noopener noreferrer">Hooks</a><ul><li><a href="/black-react-guidebook//infrastructure/hooks"><span>Hooks</span></a></li><li><a href="/black-react-guidebook//infrastructure/hooks/hooks-analysis"><span>源码分析</span></a></li><li><a href="/black-react-guidebook//infrastructure/hooks/use-state"><span>useState</span></a></li></ul></li><li><a target="_blank" rel="noopener noreferrer">旧版架构</a><ul><li><a href="/black-react-guidebook//infrastructure/old/virtual-dom"><span>Virtual DOM</span></a></li><li><a href="/black-react-guidebook//infrastructure/old/diffing-algorithm"><span>DOM DIFF 算法</span></a></li></ul></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="架构背景" data-depth="2"><a href="/black-react-guidebook//infrastructure/new/fiber#架构背景"><span>架构背景</span></a></li><li title="浏览器中的帧" data-depth="3"><a href="/black-react-guidebook//infrastructure/new/fiber#浏览器中的帧"><span>浏览器中的帧</span></a></li><li title="解决方案" data-depth="3"><a href="/black-react-guidebook//infrastructure/new/fiber#解决方案"><span>解决方案</span></a></li><li title="原有架构" data-depth="2"><a href="/black-react-guidebook//infrastructure/new/fiber#原有架构"><span>原有架构</span></a></li><li title="核心流程" data-depth="2"><a href="/black-react-guidebook//infrastructure/new/fiber#核心流程"><span>核心流程</span></a></li><li title="工作单元" data-depth="3"><a href="/black-react-guidebook//infrastructure/new/fiber#工作单元"><span>工作单元</span></a></li><li title="工作流程" data-depth="3"><a href="/black-react-guidebook//infrastructure/new/fiber#工作流程"><span>工作流程</span></a></li><li title="Fiber Tree" data-depth="3"><a href="/black-react-guidebook//infrastructure/new/fiber#fiber-tree"><span>Fiber Tree</span></a></li><li title="WorInProgress Tree" data-depth="3"><a href="/black-react-guidebook//infrastructure/new/fiber#worinprogress-tree"><span>WorInProgress Tree</span></a></li><li title="Effect List" data-depth="3"><a href="/black-react-guidebook//infrastructure/new/fiber#effect-list"><span>Effect List</span></a></li><li title="Fiber Reconciler" data-depth="3"><a href="/black-react-guidebook//infrastructure/new/fiber#fiber-reconciler"><span>Fiber Reconciler</span></a></li><li title="Reconciler - reconciliation 阶段" data-depth="3"><a href="/black-react-guidebook//infrastructure/new/fiber#reconciler---reconciliation-阶段"><span>Reconciler - reconciliation 阶段</span></a></li><li title="requestIdleCallback" data-depth="3"><a href="/black-react-guidebook//infrastructure/new/fiber#requestidlecallback"><span>requestIdleCallback</span></a></li><li title="Reconciler - commit 阶段" data-depth="3"><a href="/black-react-guidebook//infrastructure/new/fiber#reconciler---commit-阶段"><span>Reconciler - commit 阶段</span></a></li><li title="优先级策略" data-depth="3"><a href="/black-react-guidebook//infrastructure/new/fiber#优先级策略"><span>优先级策略</span></a></li><li title="源码简析" data-depth="2"><a href="/black-react-guidebook//infrastructure/new/fiber#源码简析"><span>源码简析</span></a></li><li title="总结" data-depth="2"><a href="/black-react-guidebook//infrastructure/new/fiber#总结"><span>总结</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="fiber"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#fiber"><span class="icon icon-link"></span></a>Fiber</h1><p>Fiber 是一个基于优先级策略和帧间回调的循环任务调度算法的架构方案。</p><p><strong>问题</strong>：随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是 <strong>同步阻塞</strong>。在之前的调度算法中，React 需要实例化每个类组件，生成一棵组件树，使用 <strong>同步递归</strong> 的方式进行遍历渲染，而这个过程最大的问题就是无法 <strong>暂停和恢复</strong>。</p><p><strong>解决方法</strong>：当遇到进程同步阻塞的问题时，<strong>任务分割</strong>、<strong>异步调用</strong> 和 <strong>缓存策略</strong> 是三个显著的解决思路。而 React Fiber 便是为了实现任务分割而诞生的。</p><blockquote><p>💡 Fiber 架构的核心思想就是 <strong>任务拆分</strong> 和 <strong>协同</strong>，主动把执行权交给主线程，使主线程有时间空档处理其他高优先级任务。</p></blockquote><h2 id="架构背景"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#架构背景"><span class="icon icon-link"></span></a>架构背景</h2><p>究其原因是浏览器的渲染引擎是单线程，它将 GUI 描绘、时间器处理、事件处理、JavaScript 执行、远程资源加载通通放在一起。当做某件事，只有将它做完才能做下一件事。如果有足够的时间，浏览器是会对我们的代码进行<strong>编译优化</strong>（JIT）及进行<strong>热代码优化</strong>，一些 DOM 操作，内部也会对 Reflow（重绘）进行处理。 Reflow 是一个性能黑洞，很可能让页面的大多数元素进行重新布局。</p><h3 id="浏览器中的帧"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#浏览器中的帧"><span class="icon icon-link"></span></a>浏览器中的帧</h3><blockquote><p>之前的问题主要的问题是任务一旦执行，就无法中断，JavaScript 引擎线程一直占用主线程，导致卡顿。</p></blockquote><p>页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的，小于这个值时，用户会感觉到卡顿。</p><p>1 秒 60 帧，所以每帧分到的时间是 <code>1000/60 ≈ 16.6 ms</code>。所以我们编写代码时力求不让一帧的工作量超过 16.6ms。</p></div><img alt="Life of a Frame" src="/black-react-guidebook/static/life-of-a-frame.c10efe01.png" width="800"/><div class="markdown"><p>通过上图可看到，一帧内可完成如下六个步骤的任务：</p><ul><li>用户交互输入事件（Input events）<ul><li>Blocking input events（阻塞输入事件）：例如 <code>touch</code> 或 <code>wheel</code></li><li>Non-blocking input events（非阻塞输入事件）：例如 <code>click</code> 或 <code>keypress</code></li></ul></li><li>JavaScript 引擎解析执行：执行定时器（Timers）事件等回调</li><li>帧开始（Begin frame）：每一帧事件（Per frame events），例如 <code>window resize</code>、<code>scroll</code> 或 <code>media query change</code></li><li>rAF（requestAnimationFrame）</li><li>页面布局（Layout）：计算样式（Recalculate style）和更新布局（Update Layout）</li><li>绘制渲染（Paint）：合成更新（Compositing update）、重绘部分节点（Paint invalidation）和 Record</li><li>执行 RIC (RequestIdelCallback)</li></ul><p>如果这七个步骤中，任意一个步骤所占用的时间过长，总时间超过 16ms 后，用户业务就能看到明显的卡顿。</p><p>而在上节提到的 <strong>调和阶段</strong> 花的时间过长，也就是 JavaScript 执行的时间过长，那么就有可能在用户有交互的时候，本来应该渲染下一帧，但是在当前一帧里还在执行 JavaScript，就导致用户交互不能马上得到反馈，从而产生卡顿感。</p><blockquote><p>Q：既然初衷是不希望 JavaScript 不受控制地长时间执行（想要手动调度），那么，为什么在 React 的使用中 JavaScript 长时间执行会影响交互响应、动画？</p><p>A：因为在 React v16 之前，<code>reconciliation</code> 处理框架内部更新事务的算法简单说就是一个 <strong>自顶向下的递归算法</strong>，产出需要对当前 DOM 进行更新或替换的操作列表，一旦开始，会 <strong>持续占用</strong> 主线程，中断操作却不容易实现。当 JavaScript 长时间执行时（如大量计算等），就会出现如上文所说的阻塞样式计算、绘制等工作，出现页面脱帧现象。</p></blockquote><h3 id="解决方案"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#解决方案"><span class="icon icon-link"></span></a>解决方案</h3><p>把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候再继续执行。这种策略叫做 <a target="_blank" rel="noopener noreferrer" href="https://www.w3.org/TR/requestidlecallback/">Cooperative Scheduling（合作式调度）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，操作系统常用任务调度策略之一。</p><blockquote><p><strong>补充知识</strong></p><p>操作系统常用任务调度策略：先来先服务（FCFS）调度算法、短作业（进程）有限调度算法（SJ/PF）、最高优先权优先调度算法（FPF）、高响应比优先调度算法（HRN）、时间片轮转法（RR）、多级队列反馈法。</p></blockquote><p>合作式调度主要就是用来分配任务的，当有更新任务来的时候，不会马上去做 Diff 操作，而是先把当前的更新送入一个 <strong>Update Queue</strong> 中，然后交给 <strong>Scheduler</strong> 去处理，Scheduler 会根据当前主线程的使用情况去处理这次 Update。为了实现这种特性，使用 <code>requestIdleCallback</code> API。对于不支持这个 API 的浏览器，React 会加上 pollyfill。</p><p>在上面我们已经知道浏览器是一帧一帧执行的，在两个执行帧之间，主线程通常会有一小段空闲时间，<code>requestIdleCallback</code> 可以在这个 <strong>空闲期（Idle Period）调用空闲期回调（Idle Callback）</strong>，执行一些任务。</p></div><img alt="Idle Period" src="/black-react-guidebook/static/idle-period-time.7abfafa4.png" width="800"/><div class="markdown"><ul><li>低优先级任务由 <code>requestIdleCallback</code> 处理</li><li>高优先级任务，如动画相关的就由 <code>reuqestAnimationFrame</code> 处理</li><li><code>requestIdleCallback</code> 可以在多个空闲期调用空闲期回调，执行任务</li><li><code>requestIdleCallback</code> 方法提供 deadline，即任务执行限制时间，以切分任务，避免长时间执行，阻塞 UI 渲染而导致掉帧</li></ul><p>这个方案看似确实不错，但是怎么实现可能会遇到几个问题：</p><ul><li>如何拆分成子任务？</li><li>一个子任务多大合适？</li><li>怎么判断是否还有剩余时间？</li><li>有剩余时间怎么去调度应该执行哪个任务？</li><li>没有剩余时间之前的任务怎么办？</li></ul><p>接下来整个 Fiber 架构就是来解决这些问题的。</p><h2 id="原有架构"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#原有架构"><span class="icon icon-link"></span></a>原有架构</h2><p>在开始介绍 Fiber 架构前，我们先对 React16 之前的架构有个大概的了解。</p><p>React 这个纯视图库可以分为三层架构：</p><ul><li><strong>虚拟 DOM 层</strong>：负责描述结构与逻辑</li><li><strong>内部组件层</strong>：负责组件的更新，<code>ReactDOM.render</code>、<code>setState</code>、<code>forceUpdate</code> 都是与它们打交道，能让你多次 <code>setState</code>，只执行一次真实的渲染，在适当的时机执行组件实例内生命周期钩子</li><li><strong>底层渲染层</strong>：不同的显示介质有不同的渲染方法，比如说浏览器端，它使用元素节点、文本节点，在 Native 端，会调用 Object-C 和 Java 的 GUI，在 Canvas 中，又有专门的 API 方法</li></ul><p>由于虚拟 DOM 由 JSX 转译过来，JSX 的入口函数是 <code>React.createElement</code>，可操作空间不大，第三大的底层 API 也非常稳定，因此对于 React 团队来说可优化空间较大的架构层只能是第二层。</p><h2 id="核心流程"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#核心流程"><span class="icon icon-link"></span></a>核心流程</h2><h3 id="工作单元"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#工作单元"><span class="icon icon-link"></span></a>工作单元</h3><p>为了解决之前提到解决方案遇到的问题，提出了以下几个目标：</p><ul><li>暂停工作，稍后再回来。</li><li>为不同类型的工作分配优先权。</li><li>重用以前完成的工作。</li><li>如果不再需要，则中止工作。</li></ul><p>为了做到这些，我们首先需要一种方法将任务分解为单元。从某种意义上说，这就是 Fiber，Fiber 代表一种 <strong>工作单元</strong>。</p><p>但是仅仅是分解为单元也无法做到中断任务，因为函数调用栈就是这样，每个函数为一个工作任务（work），每个工作任务（work）被称为 <strong>堆栈帧</strong>，它会一直工作，直到堆栈为空，无法中断。</p><p>所以我们需要一种 <strong>增量渲染</strong> 的调度，那么就需要重新实现一个堆栈帧的调度，这个堆栈帧可以按照自己的调度算法执行他们。另外由于这些堆栈是可以自己控制的，所以可以加入 <strong>并发</strong> 或者 <strong>错误边界</strong> 等功能。</p><p>因此 Fiber 就是重新实现的堆栈帧，而非使用 JavaScript 引擎的栈，本质上 Fiber 也可以理解为是一个 <strong>虚拟的堆栈帧</strong>，将可中断的任务拆分成多个子任务，通过按照优先级来自由调度子任务，分段更新，从而将之前的 <strong>同步渲染</strong> 改为 <strong>异步渲染</strong>。</p><p>所以我们可以说 Fiber 是一种数据结构（堆栈帧），也可以说是一种解决可中断的调用任务的一种解决方案，它的特性就是 <strong>时间分片（time slicing）</strong> 和 <strong>暂停（supense）</strong>。</p><p>如果了解 <strong>协程</strong> 的可能会觉得 Fiber 的这种解决方案，跟协程有点像（区别还是很大的），是可以中断的，可以控制执行顺序。在 JavaScript 里的 <code>generator</code> 其实就是一种协程的使用方式，不过颗粒度更小，可以控制函数里面的代码调用的顺序，也可以中断。</p><h3 id="工作流程"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#工作流程"><span class="icon icon-link"></span></a>工作流程</h3><blockquote><p>Fiber 是如何工作的？</p></blockquote><ol><li><code>ReactDOM.render()</code> 和 <code>setState</code> 的时候开始创建更新</li><li>将创建的更新加入任务队列，等待调度</li><li>在 <code>requestIdleCallback</code> 空闲时执行任务</li><li>从根节点开始遍历 Fiber Node，并且构建 WorkInProgress Tree</li><li>生成 EffectList</li><li>根据 EffectList 更新 DOM</li></ol><p>下面是一个详细的执行过程图：</p></div><img alt="React Fiber Workflow" src="/black-react-guidebook/static/fiber-workflow.5e0ace08.png" width="800"/><div class="markdown"><ol><li>第一部分从 <code>ReactDOM.render</code> 方法开始，把接收的 React Element 转换为 Fiber 节点，并为其<a href="/black-react-guidebook//infrastructure/new/fiber#%E4%BC%98%E5%85%88%E7%BA%A7%E7%AD%96%E7%95%A5">设置优先级</a>，创建 Update，加入到更新队列，这部分主要是做一些初始数据的准备。</li><li>第二部分主要是三个函数：<code>scheduleWork</code>、<code>requestWork</code>、<code>performWork</code>，即安排工作、申请工作、正式工作三部曲，React16 新增的异步调用的功能则在这部分实现，这部分就是 <strong>Schedule 阶段</strong>，前面介绍的 Cooperative Scheduling 就是在这个阶段，只有在这个解决获取到可执行的时间片，第三部分才会继续执行。</li><li>第三部分是个大循环，遍历所有的 Fiber 节点，通过 Diff 算法计算所有更新工作，产出 EffectList 给到 Commit 阶段使用，这部分的核心就是 <code>beginWork</code> 函数，这部分基本就是 <strong>FIber Reconciler</strong>，包括 <strong>reconciliation</strong> 和 <strong>commit</strong> 阶段。</li></ol><h3 id="fiber-tree"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#fiber-tree"><span class="icon icon-link"></span></a>Fiber Tree</h3><p>React 运行时存在三种实例（结合上文提到的 React 三层架构理解）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-plain"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Element - 描述 UI 结构内容（type、props）</span></div><div class="token-line"><span class="token plain">--------</span></div><div class="token-line"><span class="token plain">Instances - React 维护的 VirtualDOM Tree Node</span></div><div class="token-line"><span class="token plain">--------</span></div><div class="token-line"><span class="token plain">DOM - 真实 DOM 节点</span></div></pre></div><p>React 在首次渲染（执行 <code>ReactDOM.render</code>）时，会通过 <code>React.createElement</code> 创建一颗 Element 树，可以称之为 <strong>Virtual DOM Tree</strong>，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。它反映了用于渲染 UI 的应用程序的状态。这棵树通常被称为 <strong>current 树（当前树，记录当前页面的结构状态）</strong>。</p><p>在后续的更新过程中（<code>setState</code>），每次重新渲染都会重新创建 Element，但是 Fiber 不会，Fiber 只会使用对应的 Element 中的数据来更新自己必要的属性。这个过程在 Fiber 出现之前的 <code>reconciler</code>（称为 Stack Reconciler）是采取自顶向下递归比较来实现的，所以 <span style="color:red;font-weight:bold">无法中断这个递归比较的过程</span>（持续占用主线程），这样主线程上的布局、动画等周期性任务以及交互响应就无法立即得到处理，影响用户体验。</p><blockquote><p>⚠️ <strong>注意</strong>：Fiber 之前的 <code>reconciler</code> 被称为 Stack Reconciler，就是因为这些调度上下文信息是由系统栈来保存的。虽然之前一次性做完，强调栈没什么意义，起个名字只是为了便于区分 Fiber Reconciler。</p></blockquote><p>Fiber 解决这个问题的 <strong>思路</strong> 是把渲染/更新过程（递归 <code>diff</code>）拆分为一系列小任务，每次检查树上的一小部分，完成后检查是否还有时间继续下个任务，有的话继续，没有的话自己挂起，主线程不忙的时候再继续。</p><p>增量更新需要更多的上下文信息，之前的 VirtualDOM Tree 显然难以满足，所以扩展出了 Fiber Tree，更新过程就是根据输入数据以及现有的 Fiber Tree 构造出新的临时的 Fiber Tree（WorkInProgress tree）。</p><p>因此，Instances 层新增了这些实例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-plain"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">React Elements</span></div><div class="token-line"><span class="token plain">    描述 UI 长什么样子（type、props）</span></div><div class="token-line"><span class="token plain">--------</span></div><div class="token-line"><span class="token plain">Fiber</span></div><div class="token-line"><span class="token plain">    Fiber Tree 与 VirtualDOM Tree 类似，用于描述增量更新所需的上下文信息</span></div><div class="token-line"><span class="token plain">--------</span></div><div class="token-line"><span class="token plain">WorkInProgress</span></div><div class="token-line"><span class="token plain">    workInProgress Tree 是 Reconcile 过程中从 Fiber Tree 简历的当前进度快照，用于断电恢复</span></div><div class="token-line"><span class="token plain">--------</span></div><div class="token-line"><span class="token plain">Effect</span></div><div class="token-line"><span class="token plain">    每个 workInProgress Tree 节点上都有一个 Effect List</span></div><div class="token-line"><span class="token plain">    用于存放 diff 结果</span></div><div class="token-line"><span class="token plain">    当前节点更新完毕后会向上 merge Effect List（Queue 收集 diff 结果）</span></div><div class="token-line"><span class="token plain">--------</span></div><div class="token-line"><span class="token plain">DOM</span></div><div class="token-line"><span class="token plain">    真实 DOM 节点</span></div></pre></div><blockquote><p>⚠️ <strong>注意</strong>：放在虚线上的两层（WorkInProgress 和 Effect）都是临时的结构，仅在更新时有用，日常不持续维护。<code>Effect</code> 指的就是 <code>side effect</code>，包括将要做的 <code>DOM Change</code>。</p></blockquote><p>Fiber Tree 上各节点的主要结构（每个节点称为 FiberNode）如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type </span><span class="token maybe-class-name">Fiber</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 标识 React 元素的类型，常见的有 FunctionComponent、ClassCOmponent、Fragment、ContextConsumer</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  tag</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">WorkTag</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// ReactElement.type，也就是调用 createElement 的第一个参数</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  elementType</span><span class="token operator">:</span><span class="token plain"> any</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 异步组件 resolve 之后返回的内容，一般是 function 或 class</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  type</span><span class="token operator">:</span><span class="token plain"> any</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">/* 当前 Fibeer 的状态 */</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 不同类型的实例都会记录在 stateNode 上</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 比如 DOM 组件对应 DOM 节点实例</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// ClassComponent 对应 Class 实例</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// FunctionComponent 没有实例，所以 StateNode 值为 null</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// state 更新了或 props 更新了均会更新到 stateNode 上</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  stateNode</span><span class="token operator">:</span><span class="token plain"> any</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 指向它在 Fiber 节点树中的 `parent`，用于处理完这个节点之后向上返回</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 表示当前节点处理完毕后，应该向谁提交自己的成果（effect list）</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">return</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">Fiber</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 指向自己的第一个子节点</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  child</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">Fiber</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 指向自己的第一个兄弟节点，兄弟节点的 return 指向同一个父节点</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  sibling</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">Fiber</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// ref 属性</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  ref</span><span class="token operator">:</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">handle</span><span class="token parameter operator">:</span><span class="token parameter"> mixed</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token arrow operator">=&gt;</span><span class="token plain"> </span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token operator">&amp;</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain">_stringRef</span><span class="token operator">:</span><span class="token plain"> </span><span class="token operator">?</span><span class="token plain">string</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain"> </span><span class="token maybe-class-name">RefObject</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 更新相关</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 新的变动带来的新的 Props，即 nextProps</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  pendingProps</span><span class="token operator">:</span><span class="token plain"> any</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 上次渲染完成之后的 Props，即 props</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  memoizedProps</span><span class="token operator">:</span><span class="token plain"> any</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 该 Fiber 对应的组件产生的 Update 会存放在这个队列里</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  updateQueue</span><span class="token operator">:</span><span class="token plain"> mixed</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 上次渲染的时候的 State，即 state</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 新的 state 由 updateQueue 计算得出，并覆盖 memoizedState</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  memoizedState</span><span class="token operator">:</span><span class="token plain"> any</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 一个列表，存在该 Fiber 依赖的 contexts、events</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  dependencies</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">Dependencies</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// mode 有 conCurrentMode 和 strictMode</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 用于描述当前 Fiber 和其他子树的 Bitfield</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 共存的模式表示这个子树是否默认是异步渲染的</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// Fiber 刚被创建时，会继承父 Fiber</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 其他标识也可以在创建的时候被设置，但是创建之后不该被修改，特别是它的子 Fiber 创建之前</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  mode</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">TypeOfMode</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">/* 以下是副作用，副作用是标记组件哪些需要更新的工具、标记组件需要执行哪些生命周期的工具 */</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// Effect 类型</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  effectTag</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">SideEffectTag</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// Effect 指针，指向下个 Effect</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  nextEffect</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">Fiber</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// Effect List 单向链表中的第一个 Effect</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  firstEffect</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">Fiber</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// Effect List 单向链表中的最后一个 Effect</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  lastEffect</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">Fiber</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 达标任务在未来哪个时间点，应该被完成</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 不包括该 Fiber 的子树产生的任务</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  expirationTime</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">ExpirationTime</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">//快速确定子树中是否有 update</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">//如果子节点有update的话，就记录应该更新的时间</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  childExpirationTime</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">ExpirationTime</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 在 Fiber 树更新的过程中，每个 Fiber 都会有一个跟其对应的 Fiber</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 我们称它为 `current &lt;==&gt; workInProgress`</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 在渲染完成之后它们会交换位置</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  alternate</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">Fiber</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span></div></pre></div><p>每一个 Fiber Node 节点与 Virtual Dom 一一对应，所有 Fiber Node 连接起来形成 Fiber Tree, 是个<strong>单链表树结构</strong>，如下图所示：</p></div><img alt="Fiber Tree Sample" src="/black-react-guidebook/static/fiber-tree-sample.3803e9d4.jpeg" width="640"/><div class="markdown"><p>Fiber Tree 通过节点保存与映射，便能够随时地进行停止和重启，这样便能达到实现 <strong>任务分割</strong> 的基本前提。</p><p>在 React v16 将调度算法进行了重构，将之前的 Stack Reconciler 重构成新版的 Fiber Reconciler，变成了具有链表和指针的 <strong>单链表树遍历算法</strong>。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启。</p><p>当 <code>render</code> 的时候有了这么一条单链表，当调用 <code>setState</code> 的时候又是如何 Diff 得到 change list 的呢？</p><h3 id="worinprogress-tree"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#worinprogress-tree"><span class="icon icon-link"></span></a>WorInProgress Tree</h3><p>通过 <code>setState</code> 触发 React 内部的更新任务后，采用的是 <strong>双缓冲技术（double buffering）</strong> 从 Fiber Tree 中获取 DOM Change List，就像 Redux 里的 <code>nextListeners</code> 一样，在 Fiber 架构中则是以 Fiber Tree 为主，WorkInProgress Tree（反映的是刷新到屏幕的未来状态） 为辅。</p><p>双缓冲具体指的是 WorkInProgress Tree 构造完毕，得到的就是新的 Fiber Tree，然后把 <code>current</code> 树的指针指向 WorkInProgress Tree，然后丢掉旧的 Fiber Tree 即可。</p><p>这样做的好处：</p><ul><li>能够复用内部对象（Fiber Node）</li><li>节省内存分配、GC（垃圾回收）的时间开销</li><li>就算运行中有错误，也不会影响 View 上的错误（错误边界）</li></ul><p>每个 FiberNode 上都有个 <code>alternate</code> 属性，也指向一个 Fiber Node，创建 WorkInProgress Tree 节点时优先取 <code>alternate</code>，没有的话就创建一个：</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token keyword module">export</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">createWorkInProgress</span><span class="token punctuation">(</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token parameter">current</span><span class="token parameter operator">:</span><span class="token parameter"> Fiber</span><span class="token parameter punctuation">,</span><span class="token parameter"></span></div><div class="token-line"><span class="token parameter">  pendingProps</span><span class="token parameter operator">:</span><span class="token parameter"> any</span><span class="token parameter punctuation">,</span><span class="token parameter"></span></div><div class="token-line"><span class="token parameter">  expirationTime</span><span class="token parameter operator">:</span><span class="token parameter"> ExpirationTime</span><span class="token parameter punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token plain"> </span><span class="token maybe-class-name">Fiber</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> workInProgress </span><span class="token operator">=</span><span class="token plain"> current</span><span class="token punctuation">.</span><span class="token property-access">alternate</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">workInProgress </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    workInProgress </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">createFiber</span><span class="token punctuation">(</span><span class="token plain">current</span><span class="token punctuation">.</span><span class="token property-access">tag</span><span class="token punctuation">,</span><span class="token plain"> pendingProps</span><span class="token punctuation">,</span><span class="token plain"> current</span><span class="token punctuation">.</span><span class="token property-access">key</span><span class="token punctuation">,</span><span class="token plain"> current</span><span class="token punctuation">.</span><span class="token property-access">mode</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token spread operator">...</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    workInProgress</span><span class="token punctuation">.</span><span class="token property-access">alternate</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> current</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    current</span><span class="token punctuation">.</span><span class="token property-access">alternate</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> workInProgress</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword control-flow">else</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    workInProgress</span><span class="token punctuation">.</span><span class="token property-access">effectTag</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token maybe-class-name">NoEffect</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    workInProgress</span><span class="token punctuation">.</span><span class="token property-access">nextEffect</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    workInProgress</span><span class="token punctuation">.</span><span class="token property-access">firstEffect</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    workInProgress</span><span class="token punctuation">.</span><span class="token property-access">lastEffect</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token spread operator">...</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token spread operator">...</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">return</span><span class="token plain"> workInProgress</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span></div></pre></div><p>以上代码为简化之后的，可以发现，<code>current</code> 与 <code>workInProgress</code> 互相持有引用。</p><p>创建 WorkInProgress Tree 的过程也是一个 Diff 过程，Diff 完成之后会生成一个 Effect List，这个 Effect List 就是最终 Commit 阶段用于处理副作用的阶段。</p></div><img alt="Fiber WorkInProgress Tree" src="/black-react-guidebook/static/fiber-work-in-progress.f69f486a.png" width="540"/><div class="markdown"><h3 id="effect-list"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#effect-list"><span class="icon icon-link"></span></a>Effect List</h3><p>Effect List 可以理解为是一个存储 <code>effectTag</code> 副作用列表容器。它是由 Fiber 节点和指针 <code>nextEffect</code> 构成的单链表结构，这其中还包括第一个节点 <code>firstEffect</code>，和最后一个节点 <code>lastEffect</code>。如下图所示：</p></div><img alt="Fiber Effect List" src="data:image/png;base64,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" width="640"/><div class="markdown"><p>React 采用深度优先搜索算法，在 <code>render</code> 阶段遍历 Fiber 树时，把每一个有副作用的 Fiber 筛选出来，最后构建生成一个只带副作用的 Effect List 链表。</p><p>在 Commit 阶段，React 拿到 Effect List 数据后，通过遍历 Effect List，并根据每一个 Effect 节点的 <code>effectTag</code> 类型，从而对相应的 DOM 树执行更改。</p><p>更多 Fffect List 构建演示流程，可以点击查看动画 <a target="_blank" rel="noopener noreferrer" href="https://www.bilibili.com/video/av48384879/">Effect List —— 又一个 Fiber 链表的构建过程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><h3 id="fiber-reconciler"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#fiber-reconciler"><span class="icon icon-link"></span></a>Fiber Reconciler</h3><p>在第二部分，进行 Schedule 完，获取到时间片之后，就开始进行 <code>reconcile</code>。</p><p>Fiber Reconciler 是 React 里的调和器，这也是任务调度完成之后，如何去执行每个任务，如何去更新每个节点的过程，对应上面的第三个部分。</p><p>Fiber Reconciler 的核心流程可以分为两个阶段（phrase）：</p><ul><li><strong>Reconciliation</strong>（调和，调度算法也可称为 <code>render</code>）<ul><li>更新 <code>state</code> 与 <code>props</code></li><li>调用生命周期钩子</li><li>生成 Virtual DOM<ul><li>这里应该称为 Fiber Tree 更为恰当</li></ul></li><li>通过新旧 Virtual DOM 进行 diff 算法，获取 Virtual Change</li><li>确定是否需要重新渲染</li><li>整个过程就是通过构造 WorkInProgress Tree 得出 DOM Change</li></ul></li><li><strong>Commit</strong><ul><li>如需要，则操作 DOM 节点更新</li></ul></li></ul><h3 id="reconciler---reconciliation-阶段"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#reconciler---reconciliation-阶段"><span class="icon icon-link"></span></a>Reconciler - reconciliation 阶段</h3><p>以 Fiber Tree 为蓝本，把每个 FiberNode 作为一个工作单元，<strong>自顶向下逐节点构造</strong> WorkInProgress Tree（构建中的新 Fiber Tree）。</p><p>具体过程如下（以组件节点为例）：</p><ol><li>如果当前节点不需要更新，直接把子节点 <code>clone</code> 过来，跳到 5；要更新的话打个 <code>tag</code></li><li>更新当前（要更新）节点的各种状态（<code>props</code>、<code>state</code>、<code>context</code>等）</li><li>调用 <code>shouldComponentUpdate</code>，判断为 <code>false</code> 的话，跳到 5</li><li>调用 <code>render</code> 获得新的子节点，并为子节点创建 Fiber Node（创建过程会尽量复用现有 Fiber Node，子节点增删也发生在这里）</li><li>如果没有产生 <code>child fiber</code>，该工作单元结束，把 <code>effect list</code> 归并到 <code>return</code>，并把当前节点的 <code>sibling</code> 作为下一个工作单元；否则把 <code>child</code> 作为下一个工作单元</li><li>如果没有剩余可用时间了，等到下一次主线程空闲时才开始下一个工作单元；否则，立即开始做</li><li>如果没有下一个工作单元了（回到了 WorkInProgress Tree 的根节点），第 1 阶段结束，进入 <code>pendingCommit</code> 状态</li></ol><p>在 Reconciliation 阶段的每个工作循环（也就是上述步骤中的 1-6）中，每次处理一个 Fiber，处理完可以中断/挂起整个工作循环。通过每个节点更新结束时向上归并 <strong>Effect List</strong> 来收集任务结果，Reconciliation 结束后，WorkInProgress Tree 根节点的 Effect List 里记录了包括 DOM Change 在内的所有 <strong>Side Effect</strong>。</p><p>这个阶段会执行以下的生命周期钩子：</p><ul><li><code>[UNSAFE_]componentWillMount</code>（弃用）</li><li><code>[UNSAFE_]componentWillReceiveProps</code>（弃用）</li><li><code>getDerivedStateFromProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>[UNSAFE_]componentWillUpdate</code>（弃用）</li><li><code>render</code></li></ul><blockquote><p>⚠️ <strong>注意</strong>：由于第 1 阶段的生命周期函数可能会被多次调用，默认以 <code>low</code> 优先级（后面介绍的六种优先级之一）执行，被高优先级任务打断的话，稍后重新执行。</p></blockquote><p>构建 WorkInProgress Tree 的过程就是 diff 的过程，也就是 VirtualDOM 的数据对比，是个适合拆分的阶段，对比一部分 VirtualDOM Tree 后，通过 <code>requestIdleCallback</code> 来调度执行每组任务，每完成一个任务后回来看看有没有更高优先级的任务需要执行，有的话则立即执行，每完成一组任务，把时间控制权交还给主线程，直到下次 <code>requestIdleCallback</code> 回调再继续构建 WorkInProgress Tree。</p><p><strong>分散执行</strong>：任务分割后，就可以把小任务单元分散到浏览器的空闲期间去 <strong>排队执行</strong>，而实现的关键是两个新 API：<code>requestIdleCallback</code> 与 <code>requestAnimationFrame</code>。</p><ul><li>低优先级的任务交给 <code>requestIdleCallback</code> 处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 <code>pollyfill</code>，而且拥有 <code>deadline</code> 参数，限制执行事件，以继续切分任务</li><li>高优先级的任务交给 <code>requestAnimationFrame</code> 处理</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token comment">// 类似于这样的方式</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token function">requestIdleCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">deadline</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token arrow operator">=&gt;</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 当有空闲时间时，我们执行一个组件渲染</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 把任务塞到一个个碎片时间中去</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">while</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token plain">deadline</span><span class="token punctuation">.</span><span class="token method function property-access">timeRemaning</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token operator">&gt;</span><span class="token plain"> </span><span class="token number">0</span><span class="token plain"> </span><span class="token operator">||</span><span class="token plain"> deadline</span><span class="token punctuation">.</span><span class="token property-access">didTimeout</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token operator">&amp;&amp;</span><span class="token plain"> nextComponent</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    nextComponent </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">performWork</span><span class="token punctuation">(</span><span class="token plain">nextComponent</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></div></pre></div><blockquote><p>由于 <code>reconciliation</code> 阶段是可中断的，一旦中断之后恢复的时候又会重新执行，所以很可能 <code>reconciliation</code> 阶段的生命周期方法会被多次调用，所以在 <code>reconciliation</code> 阶段的生命周期的方法是不稳定的，我想这也是 React 为什么要废弃 <code>componentWillMount</code> 和 <code>componentWillReceiveProps</code> 方法而改为静态方法 <code>getDerivedStateFromProps</code> 的原因吧。</p></blockquote><h3 id="requestidlecallback"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#requestidlecallback"><span class="icon icon-link"></span></a>requestIdleCallback</h3><p><code>requestIdleCallback</code> 的具体用法如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token dom variable">window</span><span class="token punctuation">.</span><span class="token method function property-access">requestIdleCallback</span><span class="token punctuation">(</span><span class="token plain">callback</span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token plain"> options</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token comment">// 示例</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">let</span><span class="token plain"> handle </span><span class="token operator">=</span><span class="token plain"> </span><span class="token dom variable">window</span><span class="token punctuation">.</span><span class="token method function property-access">requestIdleCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">deadline</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token arrow operator">=&gt;</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// didTimeout 是否超时</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// timeRemaining 剩余可用时间</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">const</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain">didTimeout</span><span class="token punctuation">,</span><span class="token plain"> timeRemaining</span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> deadline</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">    </span><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token template-string template-punctuation string">`</span><span class="token template-string string">是否已超时：</span><span class="token template-string interpolation interpolation-punctuation punctuation">${</span><span class="token template-string interpolation">didTimeout</span><span class="token template-string interpolation interpolation-punctuation punctuation">}</span><span class="token template-string template-punctuation string">`</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token template-string template-punctuation string">`</span><span class="token template-string string">剩余可用可用时间：</span><span class="token template-string interpolation interpolation-punctuation punctuation">${</span><span class="token template-string interpolation function">timeRemaining</span><span class="token template-string interpolation punctuation">.</span><span class="token template-string interpolation function">call</span><span class="token template-string interpolation punctuation">(</span><span class="token template-string interpolation">deadline</span><span class="token template-string interpolation punctuation">)</span><span class="token template-string interpolation interpolation-punctuation punctuation">}</span><span class="token template-string string">ms</span><span class="token template-string template-punctuation string">`</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// do some stuff</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">const</span><span class="token plain"> now </span><span class="token operator">=</span><span class="token plain"> </span><span class="token operator">+</span><span class="token keyword">new</span><span class="token plain"> </span><span class="token class-name">Date</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">          timespent </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">10</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword control-flow">while</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token keyword">new</span><span class="token plain"> </span><span class="token class-name">Date</span><span class="token plain"> </span><span class="token operator">&lt;</span><span class="token plain"> now </span><span class="token operator">+</span><span class="token plain"> timespent</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token template-string template-punctuation string">`</span><span class="token template-string string">花了</span><span class="token template-string interpolation interpolation-punctuation punctuation">${</span><span class="token template-string interpolation">timespent</span><span class="token template-string interpolation interpolation-punctuation punctuation">}</span><span class="token template-string string">ms搞事情</span><span class="token template-string template-punctuation string">`</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token template-string template-punctuation string">`</span><span class="token template-string string">可用时间剩余</span><span class="token template-string interpolation interpolation-punctuation punctuation">${</span><span class="token template-string interpolation function">timeRemaining</span><span class="token template-string interpolation punctuation">.</span><span class="token template-string interpolation function">call</span><span class="token template-string interpolation punctuation">(</span><span class="token template-string interpolation">deadline</span><span class="token template-string interpolation punctuation">)</span><span class="token template-string interpolation interpolation-punctuation punctuation">}</span><span class="token template-string string">ms</span><span class="token template-string template-punctuation string">`</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    timeout</span><span class="token operator">:</span><span class="token plain"> </span><span class="token number">1000</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token comment">// Output：</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token comment">// 是否已超时：false</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token comment">// 剩余可用可用时间：49.535000000000004ms</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token comment">// 花了10ms搞事情</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token comment">// 可用时间剩余38.64ms</span></div></pre></div><p>⚠️ <strong>注意</strong>：<code>requestIdleCallback</code> 调度只是希望做到流畅体验，并不能绝对保证什么，例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token comment">// do some stuff</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">const</span><span class="token plain"> now </span><span class="token operator">=</span><span class="token plain"> </span><span class="token operator">+</span><span class="token keyword">new</span><span class="token plain"> </span><span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  timespent </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">300</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain"></span><span class="token keyword control-flow">while</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token keyword">new</span><span class="token plain"> </span><span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token operator">&lt;</span><span class="token plain"> now </span><span class="token operator">+</span><span class="token plain"> timespent</span><span class="token punctuation">)</span><span class="token punctuation">;</span></div></pre></div><p>如果搞事情（对应 React 中的生命周期函数等时间上不受 React 控制的东西）就花了 300ms，什么机制也保证不了流畅。</p><blockquote><p>⚠️ <strong>注意</strong>：一般剩余可用时间也就 10-50ms，可调度空间不算很宽裕。</p></blockquote><p>这个函数的兼容性并不是很好，并且它还有一个致命的缺陷：</p><blockquote><p>requestIdleCallback is called only 20 times per second - Chrome on my 6x2 core Linux machine, it&#x27;s not really useful for UI work.</p></blockquote><p>也就是说 requestIdleCallback 只能一秒调用回调 20 次，这个完全满足不了现有的情况。</p><p>早期的 React 版本在实现上使用的是 <code>requestIdleCallback</code> API，但使用 <code>requestIdleCallback</code> 实际上有一些限制，执行频次不足，以致于无法实现流畅的 UI 渲染，扩展性差。因此 React 团队放弃了 <code>requestIdleCallback</code> 用法，实现了自定义的版本。比如，在发布 v16.10 版本中，推出实验性的 Scheduler，尝试使用 MessageChannel API 和 <code>requestAnimationFrame</code> 实现 <code>requestIdleCallback</code>。更多了解可以查看 React 源码 <code>packages/scheduler</code> 部分。</p><ul><li>所以目前 React 利用 MessageChannel 模拟了 <code>requestIdleCallback</code>，将回调延迟到绘制操作之后执行</li><li>MessageChannel API 允许我们创建一个新的消息通道，并通过它的两个 MessagePort 属性发送数据</li><li>MessageChannel 创建了一个通信的管道，这个管道有两个端口，每个端口都可以通过 <code>postMessage</code> 发送数据，而一个端口只要绑定了 <code>onmessage</code> 回调方法，就可以接收从另一个端口传来的数据</li><li>MessageChannel 是一个宏任务</li></ul><p>实际使用 MessageChannel API 模拟实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token keyword">let</span><span class="token plain"> channel </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">new</span><span class="token plain"> </span><span class="token class-name">MessageChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">let</span><span class="token plain"> activeFrameTime </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">1000</span><span class="token plain"> </span><span class="token operator">/</span><span class="token plain"> </span><span class="token number">60</span><span class="token punctuation">;</span><span class="token plain"> </span><span class="token comment">// 16.6</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">let</span><span class="token plain"> frameDeadLine</span><span class="token punctuation">;</span><span class="token plain"> </span><span class="token comment">// 这一帧的截止时间</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">let</span><span class="token plain"> pendingCallback</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">let</span><span class="token plain"> </span><span class="token function-variable function">timeRemaining</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token arrow operator">=&gt;</span><span class="token plain"> frameDeadLine </span><span class="token operator">-</span><span class="token plain"> </span><span class="token dom variable">performance</span><span class="token punctuation">.</span><span class="token method function property-access">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">channel</span><span class="token punctuation">.</span><span class="token property-access">port2</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">onmessage</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> currentTime </span><span class="token operator">=</span><span class="token plain"> </span><span class="token dom variable">performance</span><span class="token punctuation">.</span><span class="token method function property-access">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 如果帧的截止时间已经小于当前时间，说明已经过期了</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> didTimeout </span><span class="token operator">=</span><span class="token plain"> frameDeadLine </span><span class="token operator">&lt;=</span><span class="token plain"> currentTime</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">didTimeout </span><span class="token operator">||</span><span class="token plain"> </span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token operator">&gt;</span><span class="token plain"> </span><span class="token number">0</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">pendingCallback</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token function">pendingCallback</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token plain"> didTimeout</span><span class="token punctuation">,</span><span class="token plain"> timeRemaining </span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain"></span><span class="token dom variable">window</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">requestIdleCallback</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token parameter punctuation">,</span><span class="token parameter"> options</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token arrow operator">=&gt;</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">rafTime</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token arrow operator">=&gt;</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&#x27;rafTime&#x27;</span><span class="token punctuation">,</span><span class="token plain"> rafTime</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// 每帧开始时间加上 16.6 就是这一帧的截止时间</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    frameDeadLine </span><span class="token operator">=</span><span class="token plain"> rafTime </span><span class="token operator">+</span><span class="token plain"> activeFrameTime</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    pendingCallback </span><span class="token operator">=</span><span class="token plain"> callback</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// 其实发消息之后，相当于添加了一个宏任务</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    channel</span><span class="token punctuation">.</span><span class="token property-access">port1</span><span class="token punctuation">.</span><span class="token method function property-access">postMessage</span><span class="token punctuation">(</span><span class="token string">&#x27;Hello&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">;</span></div></pre></div><h3 id="reconciler---commit-阶段"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#reconciler---commit-阶段"><span class="icon icon-link"></span></a>Reconciler - commit 阶段</h3><p>Commit 阶段可以理解为就是将 Diff 的结果反映到真实 DOM 的过程。</p><p>在 Commit 阶段，首先会在 <code>commitRoot</code> 里会根据 <code>effect</code> 的 <code>effectTag</code>，具体 <code>effectTag</code> 见 <a target="_blank" rel="noopener noreferrer" href="https://github.com/facebook/react/blob/504576306461a5ff339dc99691842f0f35a8bf4c/packages/shared/ReactSideEffectTags.js">源码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，进行对应的插入、更新、删除操作，根据 <code>tag</code> 不同，调用不同的更新方法。</p><p>Commit 阶段会执行如下生命周期方法：</p><ul><li><code>getSnapshotBeforeUpdate</code></li><li><code>componentDidMount</code></li><li><code>componentDidUpdate</code></li><li><code>componentWillUnmount</code></li></ul><p>注意，Commit 阶段真的是一气呵成（同步执行，无法暂停），这个阶段的实际工作量是比较大的，所以尽量不要在后三个生命周期函数里处理复杂的逻辑计算。</p><blockquote><p>处理 Effect List 三部曲：更新 DOM 树、调用组件生命周期函数以及更新 <code>ref</code> 等内部状态</p><p>注意区别 <code>reconciler</code>、<code>reconcile</code> 和 <code>reconciliation</code>：</p><ul><li><code>reconciler</code>：调和器（名词），可以说是 React 工作的一个模块，协调模块</li><li><code>reconcile</code>：调和器调和的动作（动词）</li><li><code>reconciliation</code>：只是 <code>reconcile</code> 过程的第一阶段</li></ul></blockquote><h3 id="优先级策略"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#优先级策略"><span class="icon icon-link"></span></a>优先级策略</h3><p>每个工作单元运行时有六种优先级：</p><ul><li><code>no work</code>：没有工作任务在 Pending</li><li><code>synchronous</code>（1）：与之前的 Stack Reconciler 操作一样，同步执行</li><li><code>task</code>（2）：在 <code>nextTick</code> 之前执行</li><li><code>animation</code>（3）：在下一帧之前执行</li><li><code>high</code>（4）：需要很快完成的互动才能感觉到响应</li><li><code>low</code>（5）：稍微延迟（100-200ms）执行也没有关系，数据获取或更新存储的结果</li><li><code>offscreen</code>（6）：不会被看到，但要做好工作以防它变得可见</li></ul><p>优先级说明：</p><ul><li><code>synchronous</code> 首屏（首次渲染）用，要求尽量快，不管会不会阻塞 UI 线程；</li><li><code>animation</code> 通过 <code>requestAnimationFrame</code> 来调度，这样在下一帧就能立即开始动画过程；</li><li>后三个都是由 <code>requestIdleCallback</code> 回调执行的；</li><li><code>offscreen</code> 指的是当前隐藏的、屏幕外的（看不见的）元素。</li></ul><p>高优先级的比如键盘输入（希望立即得到反馈），低优先级的比如网络请求，让评论显示出来等等。另外，紧急的事允许插队。</p><p>这样的优先级机制存在两个问题：</p><ul><li>生命周期函数怎么执行（可能被频频中断）：触发顺序、次数没有保证了</li><li><code>starvation</code>（低优先级饿死）：如果高优先级任务很多，那么低优先级任务根本没有机会执行（就饿死了）</li></ul><p><strong>简明的优先级策略</strong>：<code>文本框输入 &gt; 本次调度结束需要完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务</code></p><blockquote><p>⚠️ <strong>注意</strong>：React 17 全面开启 <code>async rendering</code>。因此 17 将会废弃多个生命周期钩子函数（<code>will</code> 系列），原因是开启 <code>async rendering</code>，在 <code>render</code> 函数之前的所有函数，都有可能被执行多次。</p><p>长期以来，原有的生命周期函数总是会诱惑开发者在 <code>render</code> 之前的生命周期函数做一些动作，现在这些动作还放在这些函数中的话，有可能会被调用多次，这肯定不是你想要的结果。在 <code>componentWillMount</code> 执行网络请求，无论请求多快都无法赶上首次 <code>render</code>，而且 <code>componentWillMount</code> 在服务端渲染也会被调用，这样的 I/O 操作放在 <code>componentDidMount</code> 里更加合适。</p><p>在 Fiber 启用 <code>async rendering</code> 之后，更没有理由在 <code>componentWillMount</code> 里执行网络请求，因为 <code>componentWillMount</code> 可能会被调用多次，谁也不会希望无谓地多次调用多次网络请求吧。</p></blockquote><h2 id="源码简析"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#源码简析"><span class="icon icon-link"></span></a>源码简析</h2><p>从 15 到 16，源码结构发生了很大变化：</p><ul><li>再也看不到 <code>mountComponent/updateComponent()</code> 了，被拆分重组成了（<code>beginWork</code>、<code>completeWork</code>、<code>commitWork</code>）</li><li><code>ReactDOMComponent</code> 也被去掉了，在 Fiber 体系下 DOM 节点抽象用 <code>ReactDOMFiberComponent</code> 表示，组件用 <code>ReactFiberClassComponent</code> 表示，之前是 <code>ReactCompositeComponent</code></li></ul><p>Fiber 体系的核心机制是负责任务调度的 <code>ReactFiberScheduler</code>，相当于之前的 <code>ReactReconciler</code>。</p><p>VirtualDOM Tree 变成 Fiber T ree 了，以前是自上而下的简单树结构，现在是基于单链表的树结构，维护的节点关系更多一些。</p></div><img alt="Fiber Tree" src="/black-react-guidebook/static/fiber-tree.aaf96541.png" width="540"/><div class="markdown"><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/black-react-guidebook//infrastructure/new/fiber#总结"><span class="icon icon-link"></span></a>总结</h2><p>React Fiber 是对 React 来说是一次革命，解决了 React 项目 <strong>严重依赖于手工优化</strong> 的痛点，通过系统级别的时间调度，实现划时代的性能优化。鬼才般的 Fiber 结构，为异常边界提供了退路，也为限量更新提供了下一个起点。</p><p>React Fiber 最终提供的关键特性主要是：</p><ul><li>增量渲染（把渲染任务拆分成块，均匀分布到多帧）</li><li>更新时能够暂停、终止、复用渲染任务</li><li>给不同类型的更新赋予优先级</li><li>并发方面新的基础能力</li></ul><p>增量渲染用来解决掉帧的问题，渲染任务拆分之后，每次只做一小段，做完一段就把时间控制权交还给主线程，而不像之前长时间占用。这种策略叫做 <code>cooperative scheduling</code>（合作式调度），操作系统的 3 种任务调度策略之一（Firefox 还对真实 DOM 应用了这项技术）。</p><p>另外，React 自身的 <code>killer feature</code> 是 Virtual DOM，两个原因：</p><ul><li>Coding UI 变简单了（不用关心浏览器应该怎么做，而是把下一刻的 UI 描述给 React 听）</li><li>既然 DOM 能 Virtued，别的（硬件、VR、Native APP）也能</li></ul><hr/><p><strong>参考资料：</strong></p><ul><li><strong>优先推荐</strong><ul><li><a target="_blank" rel="noopener noreferrer" href="https://segmentfault.com/a/1190000019592928">📝 Deep In React 之浅谈 React Fiber 架构<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://mp.weixin.qq.com/s?__biz=MzU0OTExNzYwNg==&amp;mid=2247484359&amp;idx=1&amp;sn=442d4a8c5027b58b3decfa3882b87a85&amp;chksm=fbb5880eccc20118186380d943f0f58000e3e8946405f83e70bc43fe9f7323dee6725e1a47ab&amp;token=1033099811&amp;lang=zh_CN&amp;rd2werd=1#wechat_redirect">📝 浅谈 React 16 框架架构 Fiber（2018-08-29 推荐）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://juejin.im/post/5c052f95e51d4523d51c8300">📝 React Fiber 那些事：深入解析新的协调算法（2018-12-03 推荐）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://juejin.im/post/6859528127010471949">📝 React Fiber 源码解析（2020-08-11 推荐）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://juejin.im/post/6844903975112671239">📝 这可能是最通俗的 React Fiber 打开方式（2023-10-22 推荐）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/KieSun/Dream/issues/21">📝 剖析 React 源码：调度原理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></li><li><strong>优质好文</strong><ul><li><a target="_blank" rel="noopener noreferrer" href="https://juejin.im/post/6844903518357159949">📝 React Fiber 初探（2017-12-02）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="http://www.ayqy.net/blog/dive-into-react-fiber/">📝 完全理解 React Fiber（2018-01-06）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://mp.weixin.qq.com/s/uDIknJ-WeUJnPR8S-HnTww">📝 React Fiber 初探（2018-06-19）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://zhuanlan.zhihu.com/p/37095662">📝 React Fiber 架构（2018-05-21）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://juejin.im/post/6844903655401848846">📝 React16 源码之 React Fiber 架构<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://juejin.im/post/5bed21546fb9a049e93c4bac">📝 React 重要的一次重构：认识异步渲染架构 Fiber（2018-11-15）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://zhuanlan.zhihu.com/p/54042084">📝 React Fiber 在并发模式下的运行机制（2023-01-05）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://mp.weixin.qq.com/s/Zko4ih2F0-_861cDy1-1hw">📝 如何及为什么 React Fiber 使用链表遍历组件树（2023-01-07）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://zhuanlan.zhihu.com/p/57346388">📝 深入 React Fiber 架构及源码（2023-03-09）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://zhuanlan.zhihu.com/p/95443185">📝 React Fiber 的优先级调度机制与事件系统<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></li><li><strong>React Fiber 源码分析系列</strong><ul><li><a target="_blank" rel="noopener noreferrer" href="https://juejin.im/post/5c4edbede51d453aec64531c">第一篇<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://juejin.im/post/5c501613f265da611e4e07a8">第二篇：同步模式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://juejin.im/post/5c515e58e51d45593c376bb4">第三篇：异步状态<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://juejin.im/post/5c529aba518825261f7386f6">第四篇：归纳总结<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></li></ul></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/yyt520/black-react-guidebook/edit/master/docs/infrastructure/new/fiber.md">Edit this doc on GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="Last update: ">2023/7/9 17:27:58</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="/black-react-guidebook/umi.f5521da1.js"></script>
  </body>
</html>
